--- a/lib/Log/Any/Manager.pm	2014-09-24 20:48:15.653236090 +0200
+++ b/lib/Log/Any/Manager.pm	2014-09-24 20:49:25.210794575 +0200
@@ -1,41 +1,28 @@
-package Log::Any::Manager;
-{
-  $Log::Any::Manager::VERSION = '0.11';
-}
+use 5.008001;
 use strict;
 use warnings;
+
+package Log::Any::Manager;
+
+# ABSTRACT: Internal class to manage category/adapter mappings
+$Log::Any::Manager::VERSION = '0.11';
+
 use Carp qw(croak);
-use Devel::GlobalDestruction;
 use Log::Any::Adapter::Util qw(require_dynamic);
-use Guard;
 
 sub new {
     my $class = shift;
-    my $self = { entries => [] };
-    bless $self, $class;
-
-    # Create the initial Null entry (this is always present)
-    #
-    $self->set('Null');
-    my $null_entry = $self->{entries}->[0];
-
-    # Start our category cache with any null adapters already returned from raw Log::Any
-    #
-    $self->{category_cache} = {
-        map {
-            (
-                $_ => {
-                    adapter => $Log::Any::NullAdapters{$_},
-                    entry   => $null_entry
-                }
-              )
-        } keys(%Log::Any::NullAdapters)
+    my $self  = {
+        entries         => [],
+        category_cache  => {},
+        default_adapter => {},
     };
+    bless $self, $class;
 
     return $self;
 }
 
-sub get_logger {
+sub get_adapter {
     my ( $self, $category ) = @_;
 
     # Create a new adapter for this category if it is not already in cache
@@ -49,6 +36,11 @@
     return $category_cache->{$category}->{adapter};
 }
 
+{
+    no warnings 'once';
+    *get_logger = \&get_adapter;    # backwards compatibility
+}
+
 sub _choose_entry_for_category {
     my ( $self, $category ) = @_;
 
@@ -57,7 +49,15 @@
             return $entry;
         }
     }
-    die "no entries matched '$category' - should not get here!";
+    # nothing requested so fallback to default
+    my $default = $self->{default_adapter}{$category}
+        || [ $self->_get_adapter_class("Null"), [] ];
+    my ($adapter_class, $adapter_params) = @$default;
+    require_dynamic($adapter_class);
+    return {
+        adapter_class  => $adapter_class,
+        adapter_params => $adapter_params,
+    };
 }
 
 sub _new_adapter_for_entry {
@@ -67,6 +67,12 @@
       ->new( @{ $entry->{adapter_params} }, category => $category );
 }
 
+sub set_default {
+    my ( $self, $category, $adapter_name, @adapter_params ) = @_;
+    my $adapter_class = $self->_get_adapter_class($adapter_name);
+    $self->{default_adapter}{$category} = [$adapter_class, \@adapter_params];
+}
+
 sub set {
     my $self = shift;
     my $options;
@@ -86,12 +92,7 @@
         $pattern = qr/^\Q$pattern\E$/;
     }
 
-    $adapter_name =~ s/^Log:://;    # Log::Dispatch -> Dispatch, etc.
-    my $adapter_class = (
-          substr( $adapter_name, 0, 1 ) eq '+'
-        ? substr( $adapter_name, 1 )
-        : "Log::Any::Adapter::$adapter_name"
-    );
+    my $adapter_class = $self->_get_adapter_class($adapter_name);
     require_dynamic($adapter_class);
 
     my $entry = $self->_new_entry( $pattern, $adapter_class, \@adapter_params );
@@ -100,8 +101,8 @@
     $self->_reselect_matching_adapters($pattern);
 
     if ( my $lex_ref = $options->{lexically} ) {
-        $$lex_ref =
-          Guard::guard { $self->remove($entry) if !in_global_destruction };
+        $$lex_ref = Log::Any::Manager::_Guard->new(
+            sub { $self->remove($entry) unless _in_global_destruction() } );
     }
 
     return $entry;
@@ -111,9 +112,6 @@
     my ( $self, $entry ) = @_;
 
     my $pattern = $entry->{pattern};
-    my $size    = scalar( @{ $self->{entries} } );
-    die "cannot remove bottom entry"
-      if $entry eq $self->{entries}->[ $size - 1 ];
     $self->{entries} = [ grep { $_ ne $entry } @{ $self->{entries} } ];
     $self->_reselect_matching_adapters($pattern);
 }
@@ -131,7 +129,7 @@
 sub _reselect_matching_adapters {
     my ( $self, $pattern ) = @_;
 
-    return if in_global_destruction;
+    return if _in_global_destruction();
 
     # Reselect adapter for each category matching $pattern
     #
@@ -149,4 +147,40 @@
     }
 }
 
+sub _get_adapter_class {
+    my ( $self, $adapter_name ) = @_;
+    return $Log::Any::OverrideDefaultAdapterClass if $Log::Any::OverrideDefaultAdapterClass;
+    $adapter_name =~ s/^Log:://;    # Log::Dispatch -> Dispatch, etc.
+    my $adapter_class = (
+          substr( $adapter_name, 0, 1 ) eq '+'
+        ? substr( $adapter_name, 1 )
+        : "Log::Any::Adapter::$adapter_name"
+    );
+    return $adapter_class;
+}
+
+# This is adapted from the pure perl parts of Devel::GlobalDestruction
+if ( defined ${^GLOBAL_PHASE} ) {
+    eval 'sub _in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' ## no critic
+      or die $@;
+}
+else {
+    require B;
+    my $started = !B::main_start()->isa(q[B::NULL]);
+    unless ($started) {
+        eval '0 && $started; CHECK { $started = 1 }; 1' ## no critic
+          or die $@;
+    }
+    eval ## no critic
+      '0 && $started; sub _in_global_destruction () { $started && B::main_start()->isa(q[B::NULL]) }; 1'
+      or die $@;
+}
+
+package    # hide from PAUSE
+  Log::Any::Manager::_Guard;
+
+sub new { bless $_[1], $_[0] }
+
+sub DESTROY { $_[0]->() }
+
 1;
